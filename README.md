## 自动生成readme.md文件  
* npm run create
## 前置知识
* [info.md](./info.md) 



### [index1.js](./index1.js)
* 提出问题： 给定一个整数数组 nums 和一个目标值 target，  
* 请你在该数组中找出和为目标值的那 两个 整数，  
* 并返回他们的数组下标。


### [index2.js](./index2.js)
* 提出问题：给你两个有序整数数组 nums1 和 nums2，  
* 请你将 nums2 合并到 nums1 中，  
* 使 nums1 成为一个有序数组。  
* 说明: 初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。 你可以假设 nums1 有足够的空间（空间大小大于或等于 m + n）来保存 nums2 中的元素。  
* 输入:  
* nums1 = [1,2,3,0,0,0], m = 3  
* nums2 = [2,5,6, 0], n = 3  
* 输出: [1,2,2,3,5,6]


### [index3.js](./index3.js)
* 提出问题：给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，  
* 使得 a + b + c = 0 ？  
* 请你找出所有满足条件且不重复的三元组。  
* 给定数组 nums = [-1, 0, 1, 2, -1, -4]， 满足要求的三元组集合为： [ [-1, 0, 1], [-1, -1, 2] ]  
* 双指针法


### [index4.js](./index4.js)
* 提出问题：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。  
* 左边  
* 右边


### [index5.js](./index5.js)
* 提出问题： 设计一个支持以下两种操作的数据结构：  
* void addWord(word)  
* bool search(word)  
* search(word) 可以搜索文字或正则表达式字符串，字符串只包含字母 . 或 a-z 。  
* . 可以表示任何一个字母。  
* addWord("bad")  
* addWord("dad")  
* addWord("mad")  
* search("pad") -> false  
* search("bad") -> true  
* search(".ad") -> true  
* search("b..") -> true


### [index6.js](./index6.js)
* 提出问题：请你来实现一个 atoi 函数，使其能将字符串转换成整数。  
* 首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。  
* 当我们寻找到的第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字组合起来，作为该整数的正负号；假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。  
* 该字符串除了有效的整数部分之后也可能会存在多余的字符，这些字符可以被忽略，它们对于函数不应该造成影响。  
* 注意：假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换。  
* 在任何情况下，若函数不能进行有效的转换时，请返回 0。  
* 说明：  
* 假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2^31,  2^31 − 1]。如果数值超过这个范围，请返回  INT_MAX (2^31 − 1) 或 INT_MIN (−2^31) 。  
* 示例 1:  
* 输入: "42"  
* 输出: 42  
* 示例 2:  
* 输入: " -42"  
* 输出: -42  
* 解释: 第一个非空白字符为 '-', 它是一个负号。  
* 我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。  
* 示例 3:  
* 输入: "4193 with words"  
* 输出: 4193  
* 解释: 转换截止于数字 '3' ，因为它的下一个字符不为数字。  
* 示例 4:  
* 输入: "words and 987"  
* 输出: 0  
* 解释: 第一个非空字符是 'w', 但它不是数字或正、负号。 因此无法执行有效的转换。  
* 示例 5:  
* 输入: "-91283472332"  
* 输出: -2147483648  
* 解释: 数字 "-91283472332" 超过 32 位有符号整数范围。因此返回 INT_MIN (−2^31) 。


### [index7.js](./index7.js)
* 提出问题：将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有结点组成的。   
* 提出问题：给定一个排序链表，删除所有重复的元素，使得每个元素只出现一次。  
* 输入: 1->1->2  
* 输出: 1->2  
* 示例 2:  
* 输入: 1->1->2->3->3  
* 输出: 1->2->3


### [index8.js](./index8.js)
* 提出问题：给定一个排序链表，删除所有含有重复数字的结点，只保留原始链表中 没有重复出现的数字。


### [index9.js](./index9.js)
* 提出问题：给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。


### [index10.js](./index10.js)
* 提出问题：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。  
* 输入: 1->2->3->4->5->NULL  
* 输出: 5->4->3->2->1->NULL


### [index11.js](./index11.js)
* 反转从位置 m 到 n 的链表。请使用一趟扫描完成反转。


### [index12.js](./index12.js)
* 给定一个链表判断一个链表是否有环形链


### [index13.js](./index13.js)
* 给定一个链表，返回链表开始入环的第一个节点。如果链表没有环，则返回null


### [index14.js](./index14.js)
* 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。  
* 有效字符串需满足：  
* 左括号必须用相同类型的右括号闭合。  
* 左括号必须以正确的顺序闭合。  
* 注意空字符串可被认为是有效字符串。  
* 示例 1:  
* 输入: "()"  
* 输出: true  
* 示例 2:  
* 输入: "()[]{}"  
* 输出: true  
* 示例 3:  
* 输入: "(]"  
* 输出: false  
* 示例 4:  
* 输入: "([)]"  
* 输出: false  
* 示例 5:  
* 输入: "{[]}"  
* 输出: true


### [index15.js](./index15.js)
* 根据每日气温列表，请重新生成一个列表，  
* 对应位置的输出是需要再等待多久温度才会升高超过该日的天数。  
* 如果之后都不会升高，请在该位置用 0 来代替。  
* 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，  
* 你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。  
* 气温 列表长度的范围是 [1, 30000]。  
* 每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。


### [index16.js](./index16.js)
* 题目描述：设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。  
* push(x) —— 将元素 x 推入栈中。  
* pop() —— 删除栈顶的元素。  
* top() —— 获取栈顶元素。  
* getMin() —— 检索栈中的最小元素。  
* 示例:  
* MinStack minStack = new MinStack();  
* minStack.push(-2);  
* minStack.push(0);  
* minStack.push(-3);  
* minStack.getMin(); --> 返回 -3.  
* minStack.pop();  
* minStack.top(); --> 返回 0.  
* minStack.getMin(); --> 返回 -2.  
* 时间复杂度O(1)实现


### [index17.js](./index17.js)
* 题目描述：使用栈实现队列的下列操作：  
* push(x) -- 将一个元素放入队列的尾部。  
* pop() -- 从队列首部移除元素。  
* peek() -- 返回队列首部的元素。  
* empty() -- 返回队列是否为空。  
* 示例:  
* MyQueue queue = new MyQueue();  
* queue.push(1);  
* queue.push(2);  
* queue.peek(); * 返回 1  
* queue.pop(); * 返回 1  
* queue.empty(); * 返回 false  
* 说明:  
* 你只能使用标准的栈操作 -- 也就是只有 push to top, peek/pop from top, size, 和 is empty 操作是合法的。  
* 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。  
* 假设所有操作都是有效的 （例如，一个空的队列不会调用 pop 或者 peek 操作）。


### [index18.js](./index18.js)
* * 滑动窗口问题  
* 题目描述：给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。  
* 示例:  
* 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3 输出: [3,3,5,5,6,7]  
* 解释: 滑动窗口的位置  
* ---------------  
* [1 3 -1] -3 5 3 6 7  
* 1 [3 -1 -3] 5 3 6 7  
* 1 3 [-1 -3 5] 3 6 7  
* 1 3 -1 [-3 5 3] 6 7  
* 1 3 -1 -3 [5 3 6] 7  
* 1 3 -1 -3 5 [3 6 7]  
* 最大值分别对应：  
* 3 3 5 5 6 7  
* 提示：你可以假设 k 总是有效的，在输入数组不为空的情况下，1 ≤ k ≤ 输入数组的大小。


### [index19.js](./index19.js)
* 二叉树层序遍历


### [index20.js](./index20.js)
* 给定一个没有重复数字的序列，返回其所有可能的全排列。  
* 示例：     
* 输入: [1,2,3]  
* 输出: [  
* [1,2,3],  
* [1,3,2],  
* [2,1,3],  
* [2,3,1],  
* [3,1,2],  
* [3,2,1]  
* ]  
* 变量记录当前排列内容  
* res 用来记录所有的排列顺序  
* visited 用来避免重复使用同一个数字


### [index21.js](./index21.js)
* 题目描述：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。  
* 说明：解集不能包含重复的子集。  
* 示例: 输入: nums = [1,2,3]  
* 输出:  
* [  
* [3],  
* [1],  
* [2],  
* [1,2,3],  
* [1,3],  
* [2,3],  
* [1,2],  
* []  
* ]


### [index22.js](./index22.js)
/**
 * 1.计算多个区间的交集
 *   区间用长度为2的数字数组表示，如[2, 5]表示区间2到5（包括2和5）；
 *   区间不限定方向，如[5, 2]等同于[2, 5]；
 *   实现`getIntersection 函数`
 *   可接收多个区间，并返回所有区间的交集（用区间表示），如空集用null表示
 * 示例：
 *   getIntersection([5, 2], [4, 9], [3, 6]); * [4, 5]
 *   getIntersection([1, 7], [8, 9]); * null
 */  
* [4, 5]  
* null


### [index23.js](./index23.js)
*  DOM 的体积过大会影响页面性能，假如你想在用户关闭页面时统计（计算并反馈给服务器）  
*  当前页面中元素节点的数量总和、元素节点的最大嵌套深度以及最大子元素个数，请用 JS 配合  
*  原生 DOM API 实现该需求（不用考虑陈旧浏览器以及在现代浏览器中的兼容性，可以使用任意  
*  浏览器的最新特性；不用考虑 shadow DOM）。比如在如下页面中运行后：


### [index24.js](./index24.js)
* 3.请使用原生代码实现一个Events模块，可以实现自定义事件的订阅、触发、移除功能  
* const fn1 = (... args)=>console.log('I want sleep1', ... args)  
* const fn2 = (... args)=>console.log('I want sleep2', ... args)  
* const event = new Events();  
* event.on('sleep', fn1, 1, 2, 3);  
* event.on('sleep', fn2, 1, 2, 3);  
* event.fire('sleep', 4, 5, 6);  
* * I want sleep1 1 2 3 4 5 6  
* * I want sleep2 1 2 3 4 5 6  
* event.off('sleep', fn1);  
* event.once('sleep', ()=>console.log('I want sleep));  
* event.fire('sleep');


### [index25.js](./index25.js)
* 桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。  
* 示例 1：  
* 输入：[4,2,1]  
* 输出：4  
* 解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。  
* 复制代码  
* 示例 2：  
* 输入：[2,3,10]  
* 输出：8  
* 复制代码  
* 限制：  
* 1 <= n <= 4  
* 1 <= coins[i] <= 10


### [index26.js](./index26.js)
* 给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。  
* 说明：解集不能包含重复的子集。  
* 示例: 输入: nums = [1,2,3]  
* 输出:  
* [  
* [3],  
* [1],  
* [2],  
* [1,2,3],  
* [1,3],  
* [2,3],  
* [1,2],  
* []  
* ]


### [index27.js](./index27.js)
* 给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。  
* 示例: 输入: n = 4, k = 2  
* 输出:  
* [  
* [2,4],  
* [3,4],  
* [2,3],  
* [1,2],  
* [1,3],  
* [1,4],  
* ]


### [index28.js](./index28.js)
* 给定一个二叉树, 返回它的前序(先序)遍历序列  
* 先序遍历  根 -> 左 -> 右  
* 后序遍历  左 -> 右 -> 根


### [index29.js](./index29.js)
* 二叉树 中序遍历 左 -> 中 -> 右


### [index30.js](./index30.js)
* 二叉搜索树  
* 二叉搜索树（Binary Search Tree）简称 BST，是二叉树的一种特殊形式。  
* 它有很多别名，比如排序二叉树、二叉查找树等等。  
* 定义：  
* 是一棵空树  
* 是一棵由根结点、左子树、右子树组成的树，同时左子树和右子树都是二叉搜索树，  
* 且左子树上所有结点的数据域都小于等于根结点的数据域，  
* 右子树上所有结点的数据域都大于等于根结点的数据域  
* 查找结点  
* 插入新节点  
* 暂定伪代码  
* 删除某个节点  
* 1. 节点不存在，定位到了空结点。直接返回即可  
* 2. 需要删除的目标节点没有左孩子也没有右孩子，直接删除即  
* 3. 需要删除的目标节点存在左子树，那么就去左子树里寻找小于目标节点值的最大节点，用这个节点覆盖目标节点  
* 4. 需要删除的目标节点存在右子树，那么去右子树里寻找大于目标节点值的最小节点， 用这个节点覆盖调目标节点  
* 5. 需要删除的目标节点既有左子树，又有右子树，这时就有两种方法要做，要么取左边，要么取右边  
* 判断一个树是不是二叉搜索树  
* 将一个按照升序排列的有序数组，转换为一颗高度平衡的二叉搜索树  
* 处理边界条件 


### [index31.js](./index31.js)
* 平衡二叉树  
* 平衡二叉树是任意结点的左右子树高度差绝对值都不大于1的二叉搜索树。  
* 给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。


### [index32.js](./index32.js)
* 完全二叉树  
* 1. 从第一层到倒数第二层都是满的,最后一层的节点顺序是从左到右排列的  
* 规律:   
* 1. 索引为(n-1)/2 的节点是它的父节点  
* 2. 索引为2*n + 1 的节点是它的左孩子节点  
* 3. 索引为2*n + 2 的节点是他的右孩子节点  
* 堆的概念   
* 大项堆 每个节点的值不小于其左右节点的值  
* 小项堆 每个节点的值不大于左右节点的值  
* 取出大项堆栈顶元素


### [index33.js](./index33.js)
* 排序算法  
* 1. 冒泡排序  
* 2. 插入排序  
* 3. 选择排序  
* 4. 归并排序  
* 5. 快速排序  
* 1. 冒泡排序  
* 内层循环用于完成每一轮遍历过程中的重复比较 + 交换  
* 2. 选择排序  
* 选择排序关键词最小值: 循环遍历数组,每次找出当前范围内的最小值,把它放在当前范围的头部;  
* 然后缩小排序范围,继续重复以上操作,直至数组完全有序为止  
* 3.插入排序  
* 插入排序的核心思想是找到元素在它前面那个序列中的正确位置  
* 通过正确的定位当前元素在有序序列里的位置,不断扩大有序数组的范围,最终达到完全排序的目的


### [index34.js](./index34.js)
* 分治思想  
* 1. 分解子问题  
* 2. 求解每个子问题  
* 3. 合并子问题的解,得出大问题的解  
* 归并排序  
* 分解子问题: 将需要被排序的数组从中间分割为两半,然后再将分割出来的每个子数组分割为  
* 两半,重复以上操作,知道单个子数组只有一个元素为止  
* 求解每个子问题: 从粒度最小的子数组开始,两两合并,确保每次合并出来的数组都是有序的(这里的"子问题指的  
* 每个子数组进行排序")  
* 合并子问题的解, 得出打问题的解: 当数组被合并至原有的规模是,就得到了一个完全排序的数组  
* 快速排序 选择基准值mid, 循环原数组  
* 小于基准值方左数组, 大于放右边数组, 然后concat组合,最后依靠递归完成排序


### [index35.js](./index35.js)
* 假设爬楼梯,楼梯有n阶,一次可以爬1或者2个台阶.你有多少种不同方法可以爬到楼顶.  
* n = 2  有两种 1阶 + 1阶   2阶  
* 记忆搜搜解法 自伤而底  
* 动态规划解法 自底向上


### [index36.js](./index36.js)
* 给定不同面额的硬币,和一个总金额amount,编写一个函数来计算可以凑成总金额所需的最少硬币数量  
* 如果没有任何一中应该组合能组成总金额返回-1


### [index37.js](./index37.js)
* 有 n 件物品，物品体积用一个名为 w 的数组存起来，物品的价值用一个名为 value 的数组存起来；  
* 每件物品的体积用 w[i] 来表示，每件物品的价值用 value[i] 来表示。  
* 现在有一个容量为 c 的背包，问你如何选取物品放入背包，才能使得背包内的物品总价值最大？  
* 注意: 每个物品都只有一件